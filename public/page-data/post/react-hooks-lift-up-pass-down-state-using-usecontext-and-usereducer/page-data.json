{"componentChunkName":"component---src-templates-post-js","path":"/post/react-hooks-lift-up-pass-down-state-using-usecontext-and-usereducer/","result":{"data":{"post":{"id":"315dd96c-cdd9-58a6-b185-86e17c5cca75","title":"React Hooks: Lift up / pass down state using useContext and useReducer","slug":"/react-hooks-lift-up-pass-down-state-using-usecontext-and-usereducer/","date":"March 13, 2019","excerpt":"Long post alert! I've ran into a situation where I had many child and sibling components trying to share the state between them. Earlier, Iâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"React Hooks: Lift up / pass down state using useContext and useReducer\",\n  \"date\": \"2019-03-13\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Long post alert!\"), mdx(\"p\", null, \"I\\u2019ve ran into a situation where I had many child and sibling components trying to share the state between them. Earlier, I used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prop\"), \" to send a method to share the updated states between the components. At one point of time, the number of props kept increasing and I hated that.\"), mdx(\"p\", null, \"Then came a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context\"), \" based approach to store the state in a global store and share it across. But even with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context\"), \" API, you had to have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render props\"), \" to consume the stored state from the global \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context\"), \". You will soon realise that your component becomes a nested, non-maintainable and haunting to look back.\"), mdx(\"p\", null, \"Now this post talks about how we can leverage the latest React\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hooks\"), \" concepts to achieve the same with a cleaner code.\"), mdx(\"p\", null, \"Let\\u2019s first build the sample UI with some child & sibling components.\"), mdx(\"h2\", {\n    \"id\": \"lets-ui\"\n  }, \"Let\\u2019s UI\"), mdx(\"p\", null, \"Head on to the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://codesandbox.io\"\n  }), \"CodeSandbox\"), \" to quickly experiment. Make sure that you create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React\"), \" code sandbox.\"), mdx(\"p\", null, \"Replace the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.js\"), \" with the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import React from 'react'\\nimport ReactDOM from 'react-dom'\\n\\nfunction App() {\\n  return (\\n    <div className=\\\"App\\\">\\n      <h1>Lift up / Pass down state</h1>\\n\\n      <UserList />\\n      <AddGenderToUser />\\n      <AddAgeToUser />\\n    </div>\\n  )\\n}\\n\\nfunction UserList() {\\n  return (\\n    <ul>\\n      <li>\\n        <span>Vimalraj Selvam</span>\\n        <button type=\\\"button\\\">Edit</button>\\n      </li>\\n\\n      <li>\\n        <span>Bhuvaneswari Vimalraj</span>\\n        <button type=\\\"button\\\">Edit</button>\\n      </li>\\n    </ul>\\n  )\\n}\\n\\nfunction AddGenderToUser({ username }) {\\n  return (\\n    <div>\\n      <h2>Add gender to {username}</h2>\\n      <button type=\\\"button\\\">Add Age</button>\\n    </div>\\n  )\\n}\\n\\nfunction AddAgeToUser({ username }) {\\n  return (\\n    <div>\\n      <h2>Add Age to {username}</h2>\\n      <button type=\\\"button\\\">Submit</button>\\n    </div>\\n  )\\n}\\n\\nconst rootElement = document.getElementById('root')\\nReactDOM.render(<App />, rootElement)\\n\")), mdx(\"p\", null, \"Here I\\u2019ve 3 child components to parent \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" component: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserList\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddGenderToUser\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddAgeToUser\"), \".\"), mdx(\"p\", null, \"This is very simple example. So don\\u2019t think much about the usecase of this application.\"), mdx(\"p\", null, \"I wanted to show the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddGenderToUser\"), \" component only when the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Edit\"), \" button for a particular user is clicked and update the title of the of the component with selected username.\"), mdx(\"p\", null, \"The same thing goes for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddAgeToUser\"), \" component, upon clicking the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Add Age\"), \" button from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddGenderToUser\"), \" component.\"), mdx(\"p\", null, \"First, let create a initial state of the application when no user is selected.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const initialState = {\\n  username: null,\\n  gender: null,\\n  age: null\\n}\\n\")), mdx(\"p\", null, \"Then create our reducer method to perform different actions. The actions which I can think of are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Update the user\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Set the gender for the current user\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Set the age for the current user\")), mdx(\"p\", null, \"Let\\u2019s put this in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reducer\"), \" function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const UPDATE_USER = 'UPDATE_USER'\\nconst SET_GENDER = 'SET_GENDER'\\nconst SET_AGE = 'SET_AGE'\\n\\nfunction reducer(state, action) {\\n  switch (action.type) {\\n    case UPDATE_USER:\\n      return {\\n        username: action.username,\\n        gender: null,\\n        age: null\\n      }\\n    case SET_GENDER:\\n      return {\\n        username: state.username,\\n        gender: action.gender,\\n        age: null\\n      }\\n    case SET_AGE:\\n      return {\\n        username: state.username,\\n        gender: state.gender,\\n        age: action.age\\n      }\\n    default:\\n      return initialState\\n  }\\n}\\n\")), mdx(\"p\", null, \"Our reducer method is very simple. It takes values from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"action\"), \" parameter and sets it to current state.\"), mdx(\"p\", null, \"Now let\\u2019s use this reducer function in our parent \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" component using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useReducer\"), \" hook from the react. So that we can consume the properties of reducer through the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context\"), \".\"), mdx(\"p\", null, \"Let\\u2019s add the below line just before the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return\"), \" statement of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" component.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const [user, dispatch] = React.useReducer(reducer, initialState)\\n\")), mdx(\"p\", null, \"Here \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"user\"), \" is the current state and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dispatch\"), \" is the method through which we trigger various actions defined on the reducer. To do that, we have to pass the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dispatch\"), \" method to down the line and also if any updates happens at the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state\"), \" object, the parent / other children of parent should also be aware about.\"), mdx(\"p\", null, \"To achieve the above objective, we have to leverage \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context\"), \" API from react to store our state and dispatch.\"), mdx(\"p\", null, \"Let\\u2019s initialize the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context\"), \" with the following line. This line should be before your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" function (it really doesn\\u2019t matter).\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const MyContext = React.createContext(null)\\n\")), mdx(\"p\", null, \"I\\u2019ve initialized the context with null. We\\u2019ve to put our state and dispatch into the context. To do that, let\\u2019s edit our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" component by wrapping all the childrens with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context's\"), \" provider. The updated \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" component should look like below:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"<MyContext.Provider value={{ user, dispatch }}>\\n  <UserList />\\n  {user.username && <AddGenderToUser />}\\n  {user.gender && <AddAgeToUser />}\\n</MyContext.Provider>\\n\")), mdx(\"p\", null, \"Great, now we can access the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"user\"), \" state and the corresponding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dispatch\"), \" method down the line. Also, I\\u2019ve added a conditional rendering of few child elements based on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"user\"), \" state properties \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"username\"), \" & \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gender\"), \".\"), mdx(\"p\", null, \"Let\\u2019s update our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserList\"), \" component to trigger the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UPDATE_USER\"), \" action upon clicking on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Edit\"), \" button for a particular user. To do that, we\\u2019ve to get the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dispatch\"), \" method from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context\"), \" using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useContext\"), \" hook from React.\"), mdx(\"p\", null, \"The rewritten \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserList\"), \" component:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"function UserList() {\\n  const { dispatch } = useContext(MyContext)\\n  return (\\n    <ul>\\n      <li>\\n        <span>Vimalraj Selvam</span>\\n        <button\\n          type=\\\"button\\\"\\n          onClick={() => dispatch({ type: UPDATE_USER, username: 'Vimalraj' })}\\n        >\\n          Edit\\n        </button>\\n      </li>\\n\\n      {/* Removed for brevity */}\\n    </ul>\\n  )\\n}\\n\")), mdx(\"p\", null, \"We\\u2019re dispatching \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UPDATE_USER\"), \" action and sending the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"username\"), \" along with to update the property of the state. Now when you click on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Edit\"), \" button for a particular user, you can see the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddGenderToUser\"), \" component appears. But we still don\\u2019t see the username in the appeared component. Let\\u2019s fix that!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"function AddGenderToUser() {\\n  const { user, dispatch } = useContext(MyContext)\\n\\n  return (\\n    <div>\\n      <h2>Add gender to {user.username}</h2>\\n      <button\\n        type=\\\"button\\\"\\n        onClick={() => dispatch({ type: SET_GENDER, gender: '??' })}\\n      >\\n        Add Age\\n      </button>\\n    </div>\\n  )\\n}\\n\")), mdx(\"p\", null, \"We\\u2019re getting the current \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"user\"), \" state and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dispatch\"), \" method. We extract the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"username\"), \" property to display in a title and trigger \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SET_GENDER\"), \" action upon clicking on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Add Age\"), \" button.\"), mdx(\"p\", null, \"You can repeat the same for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddAgeToUser\"), \" function as well.\"), mdx(\"p\", null, \"The completed version is available in the code sandbox, please feel free to view here.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://codesandbox.io/s/pw5zlq8zj0?fontsize=14\"\n  }), mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"src\": \"https://codesandbox.io/static/img/play-codesandbox.svg\",\n    \"alt\": \"Edit Lift up / pass down state\"\n  })))), mdx(\"p\", null, \"In the code sandbox, I\\u2019ve slightly updated the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" component to show the details once the age is updated.\"), mdx(\"p\", null, \"If this post helped you, please hit like and share.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"card":null},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"315dd96c-cdd9-58a6-b185-86e17c5cca75","excerpt":"Long post alert! I've ran into a situation where I had many child and sibling components trying to share the state between them. Earlier, Iâ€¦","slug":"/react-hooks-lift-up-pass-down-state-using-usecontext-and-usereducer/","title":"React Hooks: Lift up / pass down state using useContext and useReducer","date":"March 13, 2019","parent":{"parent":{"relativeDirectory":"react-hooks-lift-up-pass-down-state-using-usecontext-and-usereducer"}},"relativeDirectory":"react-hooks-lift-up-pass-down-state-using-usecontext-and-usereducer"}}}