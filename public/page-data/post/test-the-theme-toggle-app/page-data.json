{"componentChunkName":"component---src-templates-post-js","path":"/post/test-the-theme-toggle-app/","result":{"data":{"post":{"id":"855c4a96-dd86-54ac-95a7-1ad5f909bfa4","title":"Test the Theme toggle app using react-testing-library","date":"May 29, 2019","excerpt":"In my previous  article  we've built an app with Theme toggling capability. In this article, let's test that feature. I'll be using  react…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Test the Theme toggle app using react-testing-library\",\n  \"date\": \"2019-05-29\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In my previous \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.vimalselvam.com/2019/05/28/toggle-theme-using-react-hooks/\"\n  }), \"article\"), \" we\\u2019ve built an app with Theme toggling capability. In this article, let\\u2019s test that feature.\"), mdx(\"p\", null, \"I\\u2019ll be using \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/testing-library/react-testing-library\"\n  }), \"react-testing-library\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/testing-library/jest-dom\"\n  }), \"jest-dom\"), \" as a partner library for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react-testing-library\"), \" for leveraging custom DOM element matchers for Jest.\"), mdx(\"p\", null, \"Let\\u2019s install both the libraries as dev dependencies.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"npm install -D react-testing-library jest-dom\\n\")), mdx(\"p\", null, \"Since we used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"create-react-app\"), \", there is a nice article to get started with running tests in their doc site \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://facebook.github.io/create-react-app/docs/running-tests\"\n  }), \"here\"), \". I highly recommend my readers to read through the doc once.\"), mdx(\"p\", null, \"As mentioned \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://facebook.github.io/create-react-app/docs/running-tests#option-2-react-testing-library\"\n  }), \"here\"), \", let\\u2019s create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setupTests.js\"), \" under the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src\"), \" directory.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import 'react-testing-library/cleanup-after-each'\\nimport 'jest-dom/extend-expect'\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The 1st import ensures the rendered component by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"react-testing-library\"), \" is removed after every test ran.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The 2nd import let\\u2019s us use the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"jest-dom\"), \"\\u2019s custom matchers mainly we use it for assertion.\")), mdx(\"p\", null, \"Before writing our tests, let\\u2019s add an attribute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data-testid\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"header\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"button\"), \" component in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.js\"), \" component as like follows:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-html\"\n  }), \"<header className=\\\"App-header\\\" style={{ backgroundColor: theme.backgroundColor, color: theme.color }} data-testid=\\\"header\\\">\\n  <button type=\\\"button\\\" onClick={toggle} style={{ backgroundColor: theme.backgroundColor, color: theme.color, outline: 'none' data-testid=\\\"toggle-theme-btn\\\" >\\n    ...\\n  </button>\\n</header>\\n\")), mdx(\"p\", null, \"We\\u2019ll be using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data-testid\"), \" attribute to find the elements in our tests.\"), mdx(\"p\", null, \"Now let\\u2019s create a new test. Go and delete everything on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.test.js\"), \" and have the following test:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import React from 'react'\\nimport { render } from 'react-testing-library'\\nimport App from './App'\\n\\ntest('renders with light mode default', () => {\\n  const { getByTestId } = render(<App />)\\n  expect(getByTestId('toggle-theme-btn')).toBeInTheDocument()\\n  expect(getByTestId('header')).toHaveStyle('background-color: white')\\n})\\n\")), mdx(\"p\", null, \"In our 1st line, we render our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" component and then we assert whether there is a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Toggle theme\"), \" button and the default \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"background color\"), \" is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"white\"), \" using the respective \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data-testid\"), \"s.\"), mdx(\"p\", null, \"Let\\u2019s run the test and see whether the run is success.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"npm run test\\n\")), mdx(\"p\", null, \"Hoorah!!! The test ran successfully!\"), mdx(\"p\", null, \"Now, let\\u2019s add another test to validate whether clicking on the toggle button changes the background color.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"test('toggles the theme', () => {\\n  const { getByTestId } = render(<App />)\\n  const toggleBtn = getByTestId('toggle-theme-btn')\\n  fireEvent.click(toggleBtn)\\n  expect(getByTestId('header')).toHaveStyle('background-color: black')\\n  fireEvent.click(toggleBtn)\\n  expect(getByTestId('header')).toHaveStyle('background-color: white')\\n})\\n\")), mdx(\"p\", null, \"Make sure you import \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fireEvent\"), \" from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react-testing-library\"), \".\"), mdx(\"p\", null, \"Let\\u2019s see the run result. The newly added test failed \\uD83D\\uDE1F. Why?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"\\u2715 toggles the theme (29ms)\\n\\n  \\u25CF toggles the theme\\n\\n    expect(element).toHaveStyle()\\n\\n    - Expected\\n\\n    - background-color: black;\\n    + background-color: white;\\n\\n      13 |   const toggleBtn = getByTestId('toggle-theme-btn')\\n      14 |   fireEvent.click(toggleBtn)\\n    > 15 |   expect(getByTestId('header')).toHaveStyle('background-color: black')\\n         |                                 ^\\n      16 |   fireEvent.click(toggleBtn)\\n      17 |   expect(getByTestId('header')).toHaveStyle('background-color: white')\\n      18 | })\\n\\n      at Object.toHaveStyle (src/App.test.js:15:33)\\n\")), mdx(\"p\", null, \"The execution stack trace says that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"background-color\"), \" is still \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"white\"), \". That means after firing a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"click\"), \" event, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"localStorage\"), \"\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setItem\"), \" method is not properly triggered.\"), mdx(\"p\", null, \"To make this work, we should mock our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"localStorage\"), \" since the test doesn\\u2019t execute on the real browser and don\\u2019t have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Storage\"), \". Now open up your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setupTests.js\"), \" and append the following lines:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"let store = {}\\n\\n// Mock the `localStorage.getItem` method to return the value stored in the given key\\njest.spyOn(Storage.prototype, 'getItem').mockImplementation(key => {\\n  return store[key]\\n})\\n\\n// Mock the `localStorage.setItem` method to insert a given value into the given key\\njest.spyOn(Storage.prototype, 'setItem').mockImplementation((key, value) => {\\n  return (store[key] = value + '')\\n})\\n\\n// Mock the `localStorage.clear` method to clear the `store`\\njest.spyOn(Storage.prototype, 'clear').mockImplementation(() => {\\n  store = {}\\n})\\n\")), mdx(\"p\", null, \"Now let\\u2019s run our test and see the results. Still failing for the same reason. Let\\u2019s add some debug points with our famous \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log\"), \" statements in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"theme-context.js\"), \".\"), mdx(\"p\", null, \"I have added the following statement in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"toggle\"), \" method within our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThemeProvider\"), \" function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"console.log('>>> clicked')\\n\")), mdx(\"p\", null, \"Let\\u2019s see the run results and notice whether that statement is printed. Surprisingly, not!\"), mdx(\"p\", null, \"The reason is our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" component in the test is not wrapped with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThemeProvider\"), \". We should wrap it. Let\\u2019s do that.\"), mdx(\"p\", null, \"Once you wrapped, your test must pass and the added \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"console.log\"), \" statement should print twice!!!\"), mdx(\"p\", null, \"Great work. But do we need to wrap the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" component with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThemeProvider\"), \" in every single test. I heard you saying that\\u2019s a pain. But we have a solution for that too.\"), mdx(\"p\", null, \"So I\\u2019ve asked this question to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://twitter.com/kentcdodds\"\n  }), \"Kent\"), \" in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://twitter.com/email2vimalraj/status/1131496659685220352\"\n  }), \"twitter here\"), \". And I got immediate responses.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Yep. I recommend wrapping, but moving works too. Learn more about wrapping without the pain here: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://testing-library.com/docs/react-testing-library/setup#custom-render\"\n  }), \"https://testing-library.com/docs/react-testing-library/setup#custom-render\"))), mdx(\"p\", null, \"So as per the above, let\\u2019s create a test utility file to define our own render method. Create a file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/test-util.js\"), \" and add the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import React from 'react'\\nimport { render } from 'react-testing-library'\\nimport { ThemeProvider } from './theme-context'\\n\\nconst AllMyProviders = ({ children }) => {\\n  return <ThemeProvider>{children}</ThemeProvider>\\n}\\n\\nconst MyCustomRender = (component, options) =>\\n  render(component, { wrapper: AllMyProviders, ...options })\\n\\n// re-export everything from the `react-testing-library`\\nexport * from 'react-testing-library'\\n\\n// export our custom render method\\nexport { MyCustomRender as render }\\n\")), mdx(\"p\", null, \"Let\\u2019s go to our test and make few changes:\"), mdx(\"p\", null, \"Replace\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import { render, fireEvent } from 'react-testing-library'\\n\")), mdx(\"p\", null, \"with\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import { render, fireEvent } from './test-utils'\\n\")), mdx(\"p\", null, \"And then, remove the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThemeProvider\"), \" wrapping for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App\"), \" component in all the tests. Now execute your test and see.\"), mdx(\"p\", null, \"The tests should run fine. That\\u2019s it for today. If you found this post useful, please hit like and share it.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"card":null},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"855c4a96-dd86-54ac-95a7-1ad5f909bfa4","excerpt":"In my previous  article  we've built an app with Theme toggling capability. In this article, let's test that feature. I'll be using  react…","slug":"/test-the-theme-toggle-app/","title":"Test the Theme toggle app using react-testing-library","date":"May 29, 2019","parent":{"parent":{"relativeDirectory":"test-the-theme-toggle-app"}},"relativeDirectory":"test-the-theme-toggle-app"}}}